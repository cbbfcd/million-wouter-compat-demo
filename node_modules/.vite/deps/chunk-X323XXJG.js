import {
  DOM_REF_FIELD,
  Fragment,
  ReactCompat,
  batch,
  compat,
  createContext,
  fromDomNodeToVNode,
  h,
  hook,
  hydrate,
  jsx,
  patch,
  render,
  startTransition,
  thunk,
  useCallback,
  useContext,
  useDebugValue,
  useDeferredValue,
  useEffect,
  useId,
  useImperativeHandle,
  useLayoutEffect,
  useMemo,
  useReducer,
  useRef,
  useState,
  useSyncExternalStore,
  useTransition
} from "./chunk-7MO7ZHJA.js";

// node_modules/.pnpm/million@1.11.2/node_modules/million/dist/react.mjs
var cloneElement = (vnode) => {
  var _a;
  if (typeof vnode === "string")
    return vnode;
  return h(vnode.tag, vnode.props, ...(_a = vnode.children) != null ? _a : []);
};
var createElement = compat(h);
var isValidElement = (vnode) => {
  if (vnode && vnode !== null && vnode.constructor === void 0) {
    if (typeof vnode === "string")
      return true;
    if (vnode.tag)
      return true;
  }
  return false;
};
var memo = (component) => () => {
  return (props) => {
    return thunk(component, Object.values(props));
  };
};
var toChildArray = (children) => {
  return h("_", {}, ...children).children;
};
var mapFn = (children, fn) => {
  if (children == null)
    return null;
  return toChildArray(toChildArray(children).map(fn));
};
var Children = {
  map: mapFn,
  forEach: mapFn,
  count(children) {
    return children ? toChildArray(children).length : 0;
  },
  only(children) {
    const normalized = toChildArray(children);
    if (normalized.length !== 1)
      throw "Children.only";
    return normalized[0];
  },
  toArray: toChildArray
};
var lazy = (loader) => {
  let promise;
  let component;
  let err;
  return (props) => {
    if (!promise) {
      promise = loader();
      promise.then((exports) => component = exports.default || exports, (e) => err = e);
    }
    if (err)
      throw err;
    if (!component)
      throw promise;
    return h(component, props);
  };
};
var createRef = () => {
  return { current: null };
};
var forwardRef = (fn) => {
  return function Forwarded(props) {
    const clone = { ...props };
    delete clone.ref;
    return fn(clone, props.ref || null);
  };
};
var Suspense = (props) => {
  return props == null ? void 0 : props.children;
};
var SuspenseList = (props) => {
  return props == null ? void 0 : props.children;
};
var StrictMode = (props) => {
  return props == null ? void 0 : props.children;
};
var Component = class {
  constructor(props, context) {
    this.props = props;
    this.context = context;
    this.state = {};
    this.queueRender = batch();
  }
  componentDidMount() {
    return false;
  }
  componentDidUnmount() {
    return false;
  }
  componentDidUpdate() {
    return true;
  }
  shouldComponentUpdate(_newProps, _newState) {
    return true;
  }
  setState(update, callback) {
    const newState = {
      ...this.state,
      ...typeof update === "function" ? update(this.state, this.props) : update
    };
    if (!this.shouldComponentUpdate(this.props, newState))
      return;
    if (callback)
      callback(this.state, this.props);
    this.state = newState;
    this.queueRender(() => {
      if (this.rerender)
        this.rerender();
    });
  }
  render(props) {
    return Fragment(props);
  }
};
var PureComponent = class extends Component {
  shouldComponentUpdate(newProps, newState) {
    return newProps !== this.props && newState !== this.state;
  }
};
var React = {
  __proto__: null,
  hook,
  Children,
  Component,
  Fragment,
  PureComponent,
  StrictMode,
  Suspense,
  SuspenseList,
  unstable_SuspenseList: SuspenseList,
  cloneElement,
  createContext,
  createElement,
  createRef,
  forwardRef,
  isValidElement,
  lazy,
  memo,
  startTransition,
  unstable_startTransition: startTransition,
  useId,
  useCallback,
  useContext,
  useDebugValue,
  useDeferredValue,
  unstable_useDeferredValue: useDeferredValue,
  useEffect,
  useImperativeHandle,
  useInsertionEffect: useEffect,
  useLayoutEffect,
  useMemo,
  useMutableSource: useSyncExternalStore,
  unstable_useMutableSource: useSyncExternalStore,
  useReducer,
  useRef,
  useState,
  useSyncExternalStore,
  useTransition,
  unstable_useTransition: useTransition,
  jsx,
  jsxs: jsx,
  jsxDEV: jsx
};
var hydrateRoot = (vnode, root) => {
  hydrate(root, vnode);
  return root;
};
var createRoot = (root) => {
  const renderer = (renderFn, patchFn) => {
    return (vnode) => {
      if (!vnode)
        return;
      startTransition(() => {
        if (Array.isArray(vnode)) {
          const rootVNode = fromDomNodeToVNode(root);
          patchFn(root, h(rootVNode.tag, rootVNode.props, ...vnode));
          requestAnimationFrame(() => root[DOM_REF_FIELD] = root.firstChild);
        } else {
          renderFn(root, vnode);
        }
      });
    };
  };
  return {
    render: renderer(render, patch),
    hydrate: renderer(hydrate, patch),
    unmount: () => {
      root.textContent = "";
      root[DOM_REF_FIELD] = void 0;
    }
  };
};
var render2 = (vnode, root) => {
  startTransition(() => {
    if (Array.isArray(vnode)) {
      const rootVNode = fromDomNodeToVNode(root);
      patch(root, h(rootVNode.tag, rootVNode.props, ...vnode));
      requestAnimationFrame(() => root[DOM_REF_FIELD] = root.firstChild);
    } else {
      render(root, vnode);
    }
  });
};
var createPortal = (children, el) => {
  const rootVNode = fromDomNodeToVNode(el);
  patch(el, h(rootVNode.tag, rootVNode.props, ...children));
};
var ReactDOM = {
  __proto__: null,
  render: render2,
  createPortal,
  createRoot,
  hydrateRoot,
  flushSync: startTransition
};
var version = "18.1.0";
var index = {
  version,
  ...React,
  ...ReactDOM,
  ...ReactCompat
};

export {
  cloneElement,
  createElement,
  isValidElement,
  memo,
  Children,
  lazy,
  createRef,
  forwardRef,
  Suspense,
  SuspenseList,
  StrictMode,
  Component,
  PureComponent,
  hydrateRoot,
  createRoot,
  render2 as render,
  createPortal,
  version,
  index
};
//# sourceMappingURL=chunk-X323XXJG.js.map
